#!/usr/bin/env node

const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

const repoRoot = path.resolve(__dirname, '..');
const appEnvLocalPath = path.join(repoRoot, 'app', '.env.local');
const serviceName = 'ShekelSync';
const probeAccount = '__dev-keychain-probe__';
const keyRegex = /^[a-f0-9]{64}$/i;

function parseEnvLine(line) {
  const separatorIndex = line.indexOf('=');
  if (separatorIndex <= 0) {
    return null;
  }

  const key = line.slice(0, separatorIndex).trim();
  let value = line.slice(separatorIndex + 1).trim();
  if (!key) {
    return null;
  }

  if (
    (value.startsWith('"') && value.endsWith('"')) ||
    (value.startsWith("'") && value.endsWith("'"))
  ) {
    value = value.slice(1, -1);
  }

  return { key, value };
}

function readEnvValue(fileContent, targetKey) {
  for (const rawLine of fileContent.split(/\r?\n/)) {
    const line = rawLine.trim();
    if (!line || line.startsWith('#')) {
      continue;
    }
    const parsed = parseEnvLine(rawLine);
    if (!parsed) {
      continue;
    }
    if (parsed.key === targetKey) {
      return parsed.value;
    }
  }
  return null;
}

function isKeyValid(key) {
  return typeof key === 'string' && keyRegex.test(key);
}

function shouldTreatAsUnavailable(error) {
  const message = String(error?.message || '').toLowerCase();
  return (
    message.includes('could not connect') ||
    message.includes('no such file or directory') ||
    message.includes('org.freedesktop.secrets') ||
    message.includes('secret service') ||
    message.includes('dbus')
  );
}

async function keytarIsUsable() {
  const keytarModulePath = path.join(repoRoot, 'app', 'node_modules', 'keytar');

  let keytar;
  try {
    keytar = require(keytarModulePath);
  } catch (error) {
    return false;
  }

  try {
    await keytar.getPassword(serviceName, probeAccount);
    return true;
  } catch (error) {
    if (shouldTreatAsUnavailable(error)) {
      return false;
    }
    return false;
  }
}

function ensureEnvKeyForLinuxDev() {
  const directEnvKey = process.env.CLARIFY_ENCRYPTION_KEY;
  if (directEnvKey) {
    if (!isKeyValid(directEnvKey)) {
      throw new Error(
        'CLARIFY_ENCRYPTION_KEY is set but invalid. Expected a 64-character hex string.',
      );
    }
    return directEnvKey;
  }

  let existingContent = '';
  if (fs.existsSync(appEnvLocalPath)) {
    existingContent = fs.readFileSync(appEnvLocalPath, 'utf8');
    const fileKey = readEnvValue(existingContent, 'CLARIFY_ENCRYPTION_KEY');
    if (fileKey) {
      if (!isKeyValid(fileKey)) {
        throw new Error(
          `Invalid CLARIFY_ENCRYPTION_KEY in ${appEnvLocalPath}. Expected a 64-character hex string.`,
        );
      }
      return fileKey;
    }
  }

  const generatedKey = crypto.randomBytes(32).toString('hex');
  const prefix = existingContent && !existingContent.endsWith('\n') ? '\n' : '';
  const generatedBlock =
    `${prefix}# Auto-generated by scripts/dev-electron.js for local Linux development\n` +
    `CLARIFY_ENCRYPTION_KEY=${generatedKey}\n`;

  fs.mkdirSync(path.dirname(appEnvLocalPath), { recursive: true });
  fs.appendFileSync(appEnvLocalPath, generatedBlock, 'utf8');

  return generatedKey;
}

function runElectronDev(injectedKey) {
  const env = { ...process.env };
  if (injectedKey) {
    env.CLARIFY_ENCRYPTION_KEY = injectedKey;
  }
  // Some tooling shells export ELECTRON_RUN_AS_NODE, which breaks Electron app launch.
  delete env.ELECTRON_RUN_AS_NODE;

  const npmCommand = process.platform === 'win32' ? 'npm.cmd' : 'npm';
  const child = spawn(npmCommand, ['--prefix', 'app', 'run', 'electron-dev'], {
    cwd: repoRoot,
    env,
    stdio: 'inherit',
  });

  child.on('error', (error) => {
    console.error(`[dev-electron] Failed to start npm: ${error.message}`);
    process.exit(1);
  });

  const signals = ['SIGINT', 'SIGTERM'];
  const handlers = new Map();

  for (const signal of signals) {
    const handler = () => {
      if (!child.killed) {
        child.kill(signal);
      }
    };
    handlers.set(signal, handler);
    process.on(signal, handler);
  }

  child.on('exit', (code, signal) => {
    for (const [name, handler] of handlers.entries()) {
      process.off(name, handler);
    }
    if (signal) {
      process.kill(process.pid, signal);
      return;
    }
    process.exit(code ?? 0);
  });
}

async function main() {
  let injectedKey = null;
  const isLinux = process.platform === 'linux';

  if (isLinux) {
    const usable = await keytarIsUsable();
    if (!usable) {
      injectedKey = ensureEnvKeyForLinuxDev();
      console.log(
        `[dev-electron] Keychain unavailable on Linux. Using CLARIFY_ENCRYPTION_KEY from app/.env.local.`,
      );
    }
  }

  runElectronDev(injectedKey);
}

main().catch((error) => {
  console.error(`[dev-electron] ${error.message}`);
  process.exit(1);
});
